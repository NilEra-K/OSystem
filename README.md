# OSystem

## 🎇UC 
使用 C语言在操作系统 Unix上的用户编程, Unix系统向用户提供了大量的接口, 用户通过系统提供的接口, 可以使用操作系统提供的服务

## 🎇环境变量
- 每个进程都有一张自己的环境变量表, 表中每个条目都是形如 `"Key=Value"` 形式的环境变量
- 进程可以通过环境变量访问计算机的资源
- 在终端下输入 `env`命令, 可以查看环境变量列表
- 通过 `echo $name` 命令可以查看名为 `name` 的环境变量的值
- 环境变量分为两大类: 包括 ***全局环境变量*** 和 ***局部环境变量***
  - 全局环境变量: 当前 Shell和其子程序都是可见的
  - 局部环境变量: 只有当前 Shell可见
  - 可用 `export name` 将局部环境变量设置成全局环境变量
  - 可用 `unset name` 删除环境变量
- 环境变量的添加: 在终端中输入 `NAME=PATH` 命令即可向 ***当前进程*** 添加名为 `NAME`,值为 `PATH` 的环境变量, 如果环境变量已经存在, 就修改其值
- ⭐ 特别注意 `=` 左右 ***不能加空格***
  - 例如 `NAME = PATH` 就是错误的写法
- 常见的环境变量:
  - **PATH 环境变量:** 
    - 个人 Ubuntu下的 PATH路径: `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin`
    - 可以使用 `echo $PATH` 进行查看
    - 该环境变量所记录的是bash进程对命令的检索路径
    - 格式为 " **:** " 分割的多个路径, 当在 bash下输入命令的时候, 首先在第一个路径下找该命令的可执行程序, 找到就执行, 不再向后寻找, 找不到就向后寻找, 直到找到为止, 如果最后一个路径找不到, 就提示该命令不能找到的错误信息
    - 使用 `PATH=$PATH:.` 表示在原有路径上添加 `:.` , 即查找在执行命令时添加查找当前目录(仅在当前进程有效)
  - 如果没有特殊的操作, 对环境变量的设置仅对带你给钱的 Shell进程有效, 开启新的终端, 之前的操作不会保留
  - 在 ***用户主目录*** 下有名为 `.bashrc` 的脚本文件, 每次 _bash_ 进程启动前, 都会执行脚本文件的内容
  - 如果希望环境变量的设置对每个 _bash_ 进程都有效, 可以将环境变量的设置写在该脚本文件中
  - 执行 `source ~/.bashrc` 命令, 可以使文件立即生效
  - `nilera@nilera-virtual-machine:~$` 这个是 Linux中的提示符, 受 `PS` 路径控制, 例如:使用 `PS1='\W\$'` 命令可以只显示当前目录

## 🎇环境变量表
- 每个进程都有一张独立的环境变量表, 其中的每个条目都是一个形如 `"Key=Value"` 形式的环境变量
- 所谓的环境变量表就是一个 ***以 NULL指针结束的字符指针数组***, 其中的每个元素都是一个字符指针, 指向一个以空字符结尾的字符串, 该字符串就是形如 `"Key=Value"` 形式的环境变量, 该指针数组的地址保存在全局变量 `environ` 中

## 🎇涉及内容:
- [Done] 库文件的制作和使用
- [Done] 内存管理
- [Doing] 文件管理和文件系统
- [Doing] 进程管理
- [Doing] 信号(软中断)
- [Doing] 进程间通讯
- [Doing] 网络管理
- [Doing] 线程管理

### ✨ 库文件的制作和使用
**单一模型:** 将程序所有的功能全部实现与一个单一源文件的内部, 编译时间长, 不易于维护和升级, 不易于协作开发<p>

**分离模型:** 将程序的不同功能划分到不同的源文件中, 缩短编译时间, 易于协作开发, 不易于管理多个目标文件<p>

**什么是库文件:** 对多个目标文件的管理比较麻烦, 将多个目标文件统一整合成一个库文件<p>

***Q&A :***<p>
**_Q :_** 为什么要把一个程序分成多个源文件, 并由每个元文件编译生成独立的目标文件? <p>
**_A :_** 易于维护, 便于协作 <p>
**_Q :_** 为什么要把多个目标文件合并成一个库文件<p>
**_A :_** 易于使用, 方便复用<p>

可以简单的把库文件看成一种代码仓库, 他提供给使用者一些可以拿来使用的变量、函数或类<p>
库文件一般指计算机上的一类文件, 分 ***静态库*** 和 ***动态库*** 两种
- 静态库
  - 静态库的本质就是将多个目标文件打包成一个文件
  - 链接静态库就是将库中被调用的代码复制到调用模块中
  - 静态库的拓展名为 `.a` , 例如 `libxxx.a` 习惯在库前加 `lib` 表明其为一个库文件
  - 如何制作一个静态库 --> 查看 `./01_dir_lib/static_lib` 文件夹内容

- 动态库
  - 动态库和静态库不同, 链接动态库不需要将被调用的函数代码复制到包含调用代码的可执行文件中, 相反链接器会在调用语句处嵌入一段指令, 在该程序执行到这段指令时, 会加载该动态库并寻找被调用函数的入口地址, 并且执行该指令
  - 如果动态库中的代码同时被多个进程所用, 动态库在内存的实例仅需一份, 为所有使用该库的进程所共享, 因此动态库又叫共享库
  - 动态库的拓展名为 `.so` , 例如 `libxxx.so` 

- 静态库和动态库比较
  - 动态库: 占用内存小, 相对较慢, 程序执行必须依赖库
  - 静态库: 占用内存大, 相对较快, 程序执行不必依赖库
  - 实际开发中还是使用动态库更多, 因为动态库可以 _**更方便的**_ 进行产品的维护和迭代, 而静态库较为麻烦

- 动态库的动态加载
  - 在程序执行的过程中, 开发人员可以动态加载共享库(什么时候用什么时候加载, 减少内存资源的浪费)
  - 在程序中动态加载的动态库需要调用一组特殊的函数, 他们被声明于一个专门的头文件中, 并在一个独立的库中予以实现
  - 使用这组函数需要包含 `#include <dlfcn.h> `头文件, 并链接该库
  - **辅助工具 :**
    > 查看符号表 : nm <p>
    列出目标文件、可执行程序、静态库或共享库中的符号<p>
    例如 : `nm libmath.a`

    > 查看依赖 : ldd <p>
    查看可执行文件或者共享库所依赖的共享库 <p>
    例如 : `ldd a.out`


**相关函数:**<p>
_**`void* dlopen(char const* filename, int flag)`**_
  - 功能 : 将共享库载入内存并获得其访问句柄
  - 参数 : <p>
  **filename :** 动态库路径, 若只给文件名不带目录, 则根据 `LD_LIBRARY_PATH` 环境变量的值搜索动态库<p>
  **flag :** 加载方式, 可取以下值: <p>
  `RTLD_LAZY` - 延迟加载, 使用动态库中符号时才真正加载进内存 <p>
  `RTLD_NOW` - 立即加载 <p>
  **返回值 :** 成功返回动态库访问句柄, 失败返回 NULL <p>
  **句柄 :** 句柄唯一标识了系统内核所维护的共享库对象, 将作为后续幻术调用的参数

_**`void* dlsym(void* handle, char const* symbol)`**_
- 功能 : 从已被加载的动态库中获得特定名称的符号地址
- 参数 : <p>
  **handle :** 动态库访问句柄 <p>
  **sysbol :** 符号名 <p>
  **返回值 :** 成功返回给定符号的地址, 失败返回 NULL <p>
  该函数所返回的指针为 `void*` 类型, 需要构造与实际目标相一致类型的指针, 才能使用 <p>

_**`void* dlclose(void* handle)`**_
- 功能 : 从内存中卸载动态库
- 参数 : <p>
  **handle :** 动态库访问句柄 <p>
  **返回值 :** 成功返回 0, 失败返回非 0 <p>
- 所卸载的共享库并不一定真的从内存中立即消失, 因为其他程序可能还需要使用该库
- 只有所有使用该库的程序都显式或隐式地卸载了该库, 该库所占用的空间才会得到真正的释放
- 无论所卸载的共享库是否阵阵被释放, 传递给 dlclose函数的句柄都会在该函数成功返回后立即失效 <p>

_**`char* dlerror(void)`**_
- 功能 : 获取正在加载、使用和卸载共享库过程中所发生的错误
- **返回值 :** 有错误则返回指向错误信息字符串的指针, 否则返回 NULL

- ```
  if(!handle){
      fprintf(stderr, "dlopen: %s\n", dlerror());
      exit(EXIT_FAILURE);
  }
  ```
**错误处理 :** <p>
- 通过错误号了解具体的错误原因
  - 系统定义的整数类型全局变量 errno中存储了最近一次系统调用的错误编号
  - 头文件 `errno.h` 包含了对errno全局变量的外部生命和各种错误号的宏定义
  - `/usr/include/errno.h`
  - `/usr/include/asm-generic/errno.h`
  - `/usr/include/asm-generic/errno-base.h`

_**`char* stderror(int errnum)`**_ <p>
- 使用时需引用 `#include <string.h>` 头文件
- 功能 : 将整数形式的错误号转换为有意义的字符串
- 参数 : <p>
  **errnum :** 错误号 <p>
  **返回值 :** 返回与参数错误号对应的描述字符串 <p>

_**`void perror(char const* tag)`**_ <p>
- 使用时需引用 `#include <stdio.h>` 头文件
- 功能 : 在**标准出错设备**上打印最近一次函数调用的错误信息 <p>
- 参数 : <p>
  **tag :** 用户自己制定的提示内容, 输出时, 会自动在该提示内容和错误信息之间添加冒号进行分隔

---

### ✨ 内存管理
**程序的运作** <p>
- 我们写好的代码经过编译后得到可执行文件 `a.out` <p>
- `a.out` 是二进制指令的集合, 其内容经操作系统的管理调度被加载到物理内存, CPU在从物理内存中读取指令执行<p>
- 程序被加载到物理内存, 才能被 CPU所执行, 物理内存的空间有限, 当难以满足使用需求时, 会把一些长期闲置的代码和数据从物理内存缓存到磁盘上, 即**页面换出**, 一旦需要使用那些代码的数据, 再把他们从磁盘上恢复到物理内存中, 即**页面换入** <p>
- 磁盘上用来缓存物理内存数据的部分称为**交换分区** <p>
- 磁盘的读写速率要**远慢于**物理内存, 大量的数据换入和换出会导致电脑卡顿 <p>

**物理内存和虚拟内存**
- 虚拟地址有点像逻辑地址, 但是需要注意他们不是一个东西
- 我们在程序中所看到或者使用的地址, 并非是真实的物理内存的地址, 而是经由系统内核的内存管理系统管理后看到的虚拟地址
- 虚拟地址和物理地址之间存在映射对应关系 - 系统会维护一张内存映射表 - 物理内存(???)**透明**, 虚拟地址(###)被给予程序员
  | 物理内存 | 虚拟内存 |
  | :-: | :-: |
  | ??? | ### |

- 内存管理系统一方面**保证物理内存的安全**, 避免物理内存被直接操作, 同时也**降低了程序员的编码难度**
- CPU中包含一个名为 `MMU(Memory Management Unit)`的内存管理单元, 负责完成虚拟地址和物理地址之间的转换

**虚拟地址空间**
- 虚拟地址出现的范围即虚拟地址空间
  - 以 32位系统为例, 虚拟地址出现的范围为:
  **0x00000000 -> 0xffffffff** 也就是 `4G` , 其中 `0~3G-1`为用户所使用, 称为**用户地址空间** , `3G~4G-1` 归内核使用, 称为**内核地址空间** 
  - 64位系统中用户地址空间范围为: **0x0000 0000 0000 0000 -> 0x0000 ffff ffff ffff** , 内核地址空间为: **0x ffff 0000 0000 0000 -> 0xffff ffff ffff ffff** , 内核地址空间和用户地址空间之间是不规范地址空间, 不允许使用
- _那么我们的内存条不会产生资源的浪费吗 ?_ => **并不会** => 操作系统为每个进程都维护了一张**内存映射表** , <u> *也就是说两个不同的进程可能存在相同的虚拟地址, 但是实际上对应的物理地址并不相同, 具体的物理地址在内存映射表中记录, 目前操作系统内核可以维护 `7000+` 的内存映射表* </u>
- 对于 32位的操作系统而言, 每个进程都有 4G大小的虚拟地址空间
- 所谓的虚拟地址空间本质就是一个地址范围, 表示程序的寻址能力

**虚拟地址空间布局** <p>
_(栈区在高地址, 代码区在低地址)_ <p>
| 参数和环境区 | 命令行参数和环境变量 |
| :-: | :-: |
|栈区(Stack)|非静态局部变量|
| ⬇ |堆栈增长预留的空间|
| ⬆ |共享库共享内存等|
|堆区(Heap)|动态内存分配|
| BSS 区(BSS)|未被初始化的全局和静态局部变量|
| 数据区(Data)|不具常属性且被初始化的全局和静态局部变量|
| 代码区(Text)|可执行指令、字面值常量、具有常属性且被初始化的全局和静态局部变量|

**内存壁垒** <p>
在 **虚拟地址空间** 中提到以下内容 : <p>
> 那么我们的内存条不会产生资源的浪费吗 ? => 并不会 => 操作系统为每个进程都维护了一张内存映射表 , _**也就是说两个不同的进程可能存在相同的虚拟地址, 但是实际上对应的物理地址并不相同, 具体的物理地址在内存映射表中记录**_ , 目前操作系统内核可以维护 7000+ 的内存映射表

每个进程的用户空间都是 `0~3G-1`, 但他们所对应的物理内存却是各自独立的, 系统为每个进程的用户空间维护一张专属于该进程的内存映射表, 记录虚拟内存到物理内存的对应关系, 因此在不同进程之间交换虚拟内存是毫无意义的<p>
所有进程的内核空间都是 `3G~4G-1`, 他们所对应的物理内存只有一份, 系统为所有进程的内核空间维护一张内存映射表 `init_mm.pgd`, 记录虚拟内存到物理内存的对应关系, 因此不同进程通过系统调用所访问的内核代码和数据是同一份 <p>
*那么多个进程访问物理内存不会出错吗* -> **不会** -> 各个进程以时间片轮转的方式来使用内存 <p>

**段错误** <p>
一切对虚拟地址的越权访问, 都会导致段错误
- 试图访问没有映射到物理内存的虚拟内存
- 试图以非法的方式访问虚拟内存, 如对`只读内存(代码区的数据)`做写操作等

**内存管理** <p>
从底层硬件到上层应用, 各层都提供了各自内存管理接口, 身处不同的开发层次, 会使用不同层次的功能函数 <p>
| 开发层次 | 功能函数 | 层级 |
| :-: | :-: | :-: |
| 应用程序 | 业务逻辑 | 用户层 |
| STL | 标准容器/内存分配器 | 用户层 |
| C++ | new/delete | 用户层 |
| C | malloc/calloc/realloc/free | 用户层 |
| POSIX | sbrk/brk | 用户层 |
| Linux | mmap/munmap | 用户层 |
| 操作系统内核 | kmalloc/vmalloc | 系统层 |
| 硬件驱动程序 | get_free_page | 系统层 |
| 硬件 | 硬件指令集 | 系统层 |

**内存映射的建立与解除** <p>
**相关函数 :** <p>
_**`void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset)`**_ <p>
- 使用时需引用 `#include <sys/mman.h>` 头文件
- 功能 : 建立虚拟内存到物理内存或磁盘文件的映射
- 参数 : <p>
  **start :** 映射区虚拟内存的起始地址, `NULL`系统自动选定后返回, 程序员在编程时最好制为 `NULL` <p>
  **length :** 映射区字节数, 自动按页调整, `1页 = 4096字节`, 当申请的空间不足一页时, 分配一页; 超过一页时, 分配两页 <p>
  **prot :** 映射区操作权限, 可取以下值 : <p>
  `PROT_READ` 映射区可读 <p>
  `PROT_WRITE` 映射区可写 <p>
  `PROT_EXEC` 映射区可执行 <p>
  `PROT_NONE` 映射区不可访问 <p> 
  当又想读又想写的时需要将相应的参数进行按位或运算, 如: `PROT_READ | PROT_WRITE` <p>
  **flags :** 映射标志, 可取以下值 : <p>
  `MAP_ANONYMOUS` 匿名映射, 将虚拟内存映射到物理内存而非文件, 忽略 `fd` 和 `offset` 参数 <p>
  `MAP_PRIVATE` 对映射区的写操作只反映到缓冲区中, 并不会真正写入文件 <p>
  `MAP_SHARED` 对映射区的写操作直接反映到文件中<p>
  `MAP_DENYWRITE` 拒绝对其他文件的写操作 <p>
  `MAP_FIXED` 若在start上无法创建映射, 则失败(无次标志系统会自动调整) <p>
  `fp` 文件描述符 <p>
  `offset` 文件偏移量, 自动按页(4K)对齐 <p>
  当不进行文件操作时 _`MAP_ANONYMOUS`_ 参数必须包含, _`MAP_PRIVATE`_ 和 _`MAP_SHARED`_ 两个参数必须包含一个
  **返回值 :** 成功返回映射区虚拟内存的起始地址, 失败返回`MAP_FAILED(-1)` <p>

_**`int munmap(void* start, size_t length)`**_ <p>
- 使用时需引用 `#include <sys/mman.h>` 头文件
- 功能 : 解除虚拟内存到物理内存或磁盘文件的映射
- 参数 : <p>
  **start :** 映射区虚拟内存的起始地址 <p>
  **length :** 映射区字节数, 自动按页调整 <p>
  **返回值 :** 成功返回 `0` ,失败返回 `1`
- munmap允许对映射区的一部分解映射, 但必须按页处理 <p>

_**`void* sbrk(intptr_t increment)`**_ <p>
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 以相对方式分配和释放内存
- 参数 : <p>
  **increment :** 堆内存的字节增量(以字节为单位)<p>
  `>0` - 分配内存 <p>
  `<0` - 释放内存 <p>
  `=0` - 当前堆尾 <p>
  **返回值 :** 成功返回 _**调用该函数前的堆尾指针(也就是该段分配内存的首地址)**_ , 失败返回 -1

_**`void* brk(void* end_data_segment)`**_ <p>
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 以绝对方式分配和释放内存
- 参数 : <p>
  **end_data_segment :** 堆尾指针的目标位置 <p>
  `> 堆尾指针的原位置` - 分配内存 <p>
  `< 堆尾指针的原位置` - 释放内存 <p>
  `= 堆尾指针的原位置` - 空操作 <p>
  **返回值 :** 成功返回 _**调用该函数前的堆尾指针(也就是该段分配内存的首地址)**_ , 失败返回 -1

**虚拟内存的分配和释放**<p>
- 事实上, sbrk和 brk不过是移动堆尾指针的两种不同方法, 移动过程中还要兼顾虚拟内存和物理内存之间映射关系的建立与解除(以页为单位)
- 用 sbrk分配内存比较方便, 用多少内存就传多少增量参数, 同时返回新分配内存区域的指针, 但用 sbrk作一次性内存释放比较麻烦, 所以必须将所有的既往增量进行类加
- 用 brk释放内存比较方便, 只需将堆尾指针设回到一开始的位置即可释放调之前分多次分配的内存, 但用 brk分配内存比较麻烦, 因为必须根据所需要的内存大小计算出堆尾指针的绝对位置
- 所以实际开发中一般用 sbrk分多次分配适量内存, 最后用 brk一次性整体释放

**内存管理**
- **[最底层]** mmap/munmap底层不维护任何东西, 只是返回一个首地址, 所分配内存位于堆中
- **[中间层]** brk/sbrk底层维护一个指针, 记录所分配的内存结尾, 所分配内存位于堆中, 底层调用 mmap/munmap
- **[最上层]** malloc底层维护一个线性链表和必要的控制信息, 不可越界访问, 所分配内存位于堆中, 底层调用 brk/sbrk
- 每个进程都有 4G的虚拟地址空间, 虚拟内存地址只是一个数字, 在与世纪物理内存建立映射之前是不能访问的
- 所谓内存分配与释放, 其本质就是建立或解除从虚拟内存到物理内存的映射, 并在底层维护不同形式的数据结构, 以把虚拟内存的占用与空闲情况记录下来

**Unix 应用的层次结构**
- Unix/Linux系统的大部分功能都是通过系统调用实现的, 如 `open`、`close` 等
- Unix/Linux的系统调用已被封装成 C函数的形式, 但他们并不是 C语言标准库的一部分
- 标准库函数大部分时间运行在 _**用户态**_ , 但部分函数偶尔也会调用系统调用进入 _**内核态**_ , 如 `malloc`、 `free` 等
- 程序员自己编写的代码也可以跳过标准库, 直接使用系统调用, 如 `brk`、`sbrk`、`mmap`、`munmap` 等, 与操作系统内核交互, 进入内核态

---

### ✨ 文件管理和文件系统
**文件系统的逻辑结构** <p>
![avatar](./03_dir_file/src/fileSysLogic.png)
一个磁盘驱动器被划分成一到多个分区, 其中每个分区上都建有独立的文件系统, 每个文件系统包括 : 
- 引导块 : 计算机加电启动时, ROM BIOS从这里读取可执行代码和程序, 以完成操作系统字举
- 超级块 : 记录文件系统的整体信息, 如文件系统的格式和大小, i节点和数据块的总量、 使用量和剩余量等
- 若干柱面组, 其中每个柱面族包括 : 
  - 超级块副本: 同上
  - 柱面组信息 : 柱面族的整体描述
  - i节点映射表 : i节点号与 i节点磁盘位置的对应表
- 文件在磁盘上的存储方式 : **i节点  + 数据块**的方式保存
```
                 +--------------------+
文件 -> i节点 ->  |        元数据        |
                 +--------------------+
                 | 数据块编号(可以为多个) |
                 +--------------------+
```
- i节点, 即索引节点(Index Node, inode)
  - 磁盘中的每个文件或目录都有唯一的一个 i节点与之对应
  - 每个 i节点都有唯一的编号即 i节点号, 通过 i结点映射表可以查到与每个 i节点号相对应的 i节点在磁盘上的存储位置
  - 文件名与 i节点号的对应关系记录在该文件所在目录的目录文件中, 目录文件中的一条这样的记录就是一个硬链接
  - 用 `ls -i` 命令可以查看文件的 i节点号
  - i节点的具体内容包括 :
    - 文件类型和权限
    - 文件的硬链接数
    - 文件的用户和组
    - 文件的字节大小
    -文件的最后访问时间、最后修改时间和最后状态改变时间
    - 文件数据块索引表
- 数据块(Data Block), _512/1024/4096字节_ (取决于不同的文件系统)
  - 直接块: 存储文件的实际内容数据
    - 文件块: 存储普通文件的内容数据
    - 目录块: 存储目录文件的内容数据
  - 间接块: 存储下级文件数据块索引表
  ```
  直接块:          间接块
  +========+      +========+
  | +----+ |      | +----+ |
  | | 文 | |      | | 10 |-+---> 直接块
  | | 件 | |      | +----+ |
  | | 内 | |      | +----+ |
  | | 文 | |      | | 20 |-+---> 直接块
  | +----+ |      | +----+ |
  +========+      +========+
  ```
**文件访问流程** <p>
针对给定的文件名, 从其所在目录中可以得到与之对应的 i节点号, 在通过 i节点映射表可以查到该 i节点在磁盘上的具体位置, 读取 i节点信息并从中找到数据块索引, 进而找到相应的数据块, 最终获得文件的完整内容 <p>

**文件类型** <p>
普通文件 : 
- 在 Unix/Linux系统中通常所见到的文件, 如 C/C++语言编写的源代码文件, 编译器、汇编器和链接器产生的汇编文件、目标文件和可执行文件, 各种系统配置文件, Shell脚本文件, 音视频数字内容等多媒体文件, 乃至包括数据库在内的各种应用程序所维护、管理和使用的数据文件等, 都是普通文件
- 组成文件的线性数组里字节的数目, 即文件长度或称文件大小, 其最大值受限于 Linux内核中用于管理文件的 C语言代码数据类型的大小, 某些文件系统还可能强加自己的限制, 将其限定在更小的值
- 操作系统内核并没有对并发文件访问强加任何限制, 不同的进程能够同时读写同一个文件, 并发访问的结果取决于独立操作的顺序, 且通常是不可预测的
- 一个文件包括两部分数据, **一部分是元数据**, 如文件的类型、权限、大小、用户、组、各种时间戳等, 存储在 i节点中; **另一部分是内容数据**, 存储在数据块中<p>

**目录文件** <p>
- 系统通过 i节点号唯一地标识一个文件的存在, 但人们更愿意使用有意义的文件名来访问文件, 目录就是用来建立文件名和 i节点号之间的映射的
- 目录的本质就是一个普通文件, 与其他普通文件唯一的区别就是它仅仅存储文件名和 i节点号的映射, 每一个这样的映射, 用目录中的一个条目表示, 谓之硬链接
- 既然目录也是文件, 那么它同样也有自己的 i节点, 每个目录的 i节点号和它的文件名(目录名)之间的映射, 记录在它的父目录中, 以此类推, 形成了一颗目录树
- 根目录的 i节点在 i节点表中的存储位置是**固定的**, 因此即使没有父目录, 根目录也能被正常访问
- 当系统内核打开类似 `"/home/nilera/OSystem/03_dir_file/hello.c"` 这样的目录时, 他会从根目录开始遍历路径中每一个目录项来查找下一项的 i节点号, **根目录**的 i节点可以直接获取到, 这样就可以在根目录找到 **home目录**的 i节点号, 然后在 **home目录**中找到 **nilera目录**的 i节点号, 再在 **nilera目录**中找到 **OSystem目录**的 i节点号, 依次类推, 最终在 **03_dir_file目录**下找到 **hello.c文件**的 i节点号, 并打开次文件
- 如果路径字符串的第一个字符不是 "`/`", 则表示相对路径, 基于相对路径的路径解析从当前目录开始
- 每个目录都有两个特殊的条目, `.` 和 `..` , 分别映射该目录本身和其父目录的 i节点号, 根目录没有父目录, 故其 `.` 和 `..` 一样映射到根目录本身 <p>

**符号链接文件 :**
- 软链接和硬链接(使用 `ls -l -i -a`命令查询)
  - `2903643 -rw-rw-r--` **_`1`_** `nilera nilera 20304  5月 30 10:06 envirion`
  - 硬链接: i节点号相同, 文件名不同, 对应位置会显示两个名字(上述重斜体部分), 简单来说, 硬链接就是一个 i节点多了个名字
  - 软链接: i节点号不同, 数据块中存储的是所链接文件的路径
- 符号链接文件看上去像普通文件, 每个符号链接文件都有自己的 i节点和包含被链接文件路径名的数据块
- 相比于硬链接, 符号连接的解析需要更大的开销, 因为有效的解析符号连接至少需要解析两个文件, 即符号连接文件本身和他所链接的文件
- 通过命令 `ln -s xxx.c yyy.c` 可以创建一个符号链接

**特殊文件** <p>
特殊文件是以文件形式表示的内核对象, 具体包括 :
- 本地套接字 : 套接字是网络编程的基础, 本地套接字是面向本机通信的一个变种, 他需要依赖文件系统中的一种特殊文件, 即本地套接字文件
- 字符设备 : 设备驱动将字节按顺序写入队列, 用户程序从队列中按其被写入的顺序将字节依次读出, 如键盘
- 块设备 : 设备驱动将字节数组映射到可寻址的设备上, 用户程序可以任意顺序的访问数组中的任意字节, 如硬盘
- 有名管道 : 有名管道是一种以文件描述符为信道的进程间通信(IPC)机制, 技术是不相关的进程也能通过有名管道文件交换数据

**文件类型** <p>
可以通过 `ls -l`命令查看文件类型
- `-` : 普通文件
- `d` : 目录文件
- `s` : 本地套接字
- `c` : 字符设备
- `b` : 块设备
- `l` : 符号链接
- `p` : 有名管道

**相关函数 :** <p>
> 一个小技巧, 当我们看见很奇怪的函数返回值的时候(如`ssize_t` `size_t`等), 可以使用 `gcc -E filename.c -o filename.i`命令来进行编译, 然后查看 `filename.i`的文件内容, 在一般模式下, 输入 `/findword` 查找要查询的内容, 就可以确定其类型 <p>
例如: `size_t` 当我们使用 `gcc -E filename.c -o filename.i` 编译后, 查看文件内容, 输入 `/size_t` `ssize_t` 即可查到所有和这两个有关的内容 <p>
`size_t` 为 `long unsigned int` <p> 
`ssize_t`为`long int`

_**`int open(char const* pathname, int flags, mode_t mode)`**_ <p>
- 使用时需引用 `#include <fcntl.h>` 头文件
- 功能 : 打开已有的文件或创建新文件
- 参数 : <p>
  **pathname :** 文件路径 <p>
  **flags :** 状态标志, 可以取以下值
  `O_RDONLY` 只读 <p>
  `O_WRONLY` 只写 <p>
  `O_RDWR` 读写 <p>
  `O_APPEND` 追加 <p>
  `O_CREAT` 不存在即创建, 以存在即打开 <p>
  `O_EXCL` 不存在即创建, 以存在即报错 <p>
  `O_TRUNC` 不存在即创建, 以存在即清空 <p>
  其中, `O_RDONLY`、`O_WRONLY`、`O_RDWR`, 三个参数必须三选一, `O_CREAT`、`O_EXCL`两个参数一般同时使用, 表示不存在即创建, 存在即报错 <p>
  **mode :** 权限模式, 仅在创建新文件时有效, 可用形如 `0xxx` 的三位八进制数来表示, 由高到底一次表示拥有者用户、同组用户和其他用户的读、写、执行权限, 读权限用 4表示, 写权限用 2表示, 执行权限用 1表示, 最后通过加法将这些不同的权限组合在一起
- 返回值 : 返回的一定是当前未被使用的最小文件描述符
- 调用进程的权限掩码会屏蔽掉创建文件时制定的权限位, 如创建文件时指定权限0666, 进程权限掩码 0022(不一定是 0022, 可以使用 `umask` 命令查询当前的进程权限掩码), 所创建文件的实际权限为 : 0666&~0022 = 0664(rw-r--r--)

_**`int close(int fd)`**_ <p>
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 关闭处于打开状态的文件描述符
- 参数 : <p>
  **fd :** 处于打开状态的文件描述符

_**`ssize_t write(int fd, void const* buf, size_t count)`**_ <p>
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 向指定文件写入数据
- 参数 : <p>
  **fd :** 文件描述符 <p>
  **buf :** 内存缓冲区, 即要写入的数据 <p>
  **count :** 期望写入的字节数 <p>
  **返回值 :** 成功返回实际写入的字节数, 失败返回 -1 <p>

_**`ssize_t read(int fd, void const* buf, size_t count)`**_ <p>
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 从指定文件读入数据
- 参数 : <p>
  **fd :** 文件描述符 <p>
  **buf :** 内存缓冲区, 即要写入的数据 <p>
  **count :** 期望写入的字节数 <p>
  **返回值 :** 成功返回实际读取的字节数, 失败返回 -1 <p>

_**`off_t lseek(int fd, off_t offset, int whence)`**_
- 使用时需引用 `#include <unistd.h>` 头文件
- 功能 : 人为调整文件读写位置
- 参数 : <p>
  **fd :** 文件描述符 <p>
  **offset :** 文件读写位置偏移字节数 <p>
  **whence :** offset的参数偏移起点, 可取以下值: <p>
  `SEEK_SET` 从文件头(首字节)开始 <p>
  `SEEK_CUR` 从当前位置(最后被读写字节的下一个字节)开始 <p>
  `SEEK_END` 从文件尾(最后一个字节的下一个字节)开始 <p>
  **返回值 :** 成功返回调整后的文件读写位置, 失败返回-1<p>

**文件的内核结构** <p>
一个处于打开状态的文件, 系统会为其在内核中维护一套专门的数据结构, 保存该文件的信息, 直到它被关闭
- v 节点与 v节点表
  - 文件的元数据和在磁盘上的存储位置都保存在其 i节点中, 而 i节点保存在分区柱面组的 i节点表中, 在打开文件时将其 i节点信息读入内存, 并辅以其他的必要信息形成一个专门的数据结构, 势必会提高对该文件的访问效率,
  - 这个存在于进程的内核空间, 包含文件 i节点信息的数据结构被称为 **v节点**
  - 多个 **v节点**结构以链表的形式构成 **v节点表**
- 文件表项与文件表
  - 由**文件状态标志**(来自 **open函数**的 `flags` 参数)、**文件读写位置**(最后一次读写的最后一个字节的下一个位置, 由系统维护)和 **v节点指针**等信息组成的内核数据结构被称为文件表项
  - 通过文件表项一方面可以实时记录每次读写操作的准确位置, 另一方面可以通过 v节点指针访问该文件各种元数据和和磁盘在内的 i节点信息
  - 多个文件表项以链表形式构成文件表
- 多次打开同一个文件, 无论是多个进程还是一个进程中, 都只会在 _系统内核_ 中产生一个 v节点
- 每次打开文件都会产生一个新的文件表项, 各自维护各自文件状态标志和文件偏移, 却可能因为打开的是同一个文件而共享一个 v节点
- 打开一个文件意味着内存资源(v节点、文件表项)的分配, 而关闭这些文件其实就是为了释放这些资源, 但如果所关闭的文件在其他进程中正处于开启状态, 那么 v节点并不会释放, 直到系统中所有曾打开过该文件的进程都显示或者隐式的将其关闭, 其 v 节点才会真正的释放
- 一个处于打开状态的文件也可以被删除, 但是他所占用的磁盘空间直到他的 v节点彻底消失后才会被标记自由

**文件描述符** <p>
- 由文件的内核结构可知, 一个被打开的文件在系统内核中通过文件表项和 v节点加以标识
- 有关该文件的所有后续操作——如读取、写入、随机访问,乃至关闭等, 都无一例外地要依赖于文件表项和 v节点. 因此有必要将文件表项和 v节点体现在完成这些后续操作的函数的参数中. 但这又势必会将位于内核空间中的内存地址暴露给运行于用户空间中的程序代码, 一旦某个用户进程出现操作失误, 极有可能造成系统内核失稳, 进而影响其它正常运行的用户进程这将对操作系统的安全运行造成极大的威胁
- 为了解决内核对象在可访问性与安全性之间的矛盾, Unix系统通过所谓的文件描述符, 将位于内核空间中的文件表项间接地提供给运行于用户空间中的程序代码为了便于管理在系统中运行的各个进程, 内核会维护一张存有各进程信息的列表谓之进程表. 系统中的每个进程在进程表中都占有一个表项, 每个进程表项都包含了针对特定进程的描述信息——如进程ID、用户ID、组ID等, 其中也包含了一个被称为文件描述符表的数据结构
- 文件描述符表的每个表项都至少包含两个数据项——文件描述符标志和文件表项指针, 而所谓文件描述符, 其实就是文件描述符表项在文件描述符表中从 0开始的下标
- 作为文件描述符表项在文件描述符表中的下标, 合法的文件描述符一定是个大于等于0的整数
- 每次产生新的文件描述符表项, 系统总是从下标 0开始在文件描述符表中寻找**最小的**未使用项
- 每关闭一个文件描述符无论被其索引的文件表项和 v节点是否被删除, 与之对应的文件描述符表项一定会被标记为未使用，并在后续操作中为新的文件描述符所占用
- 系统内核缺省为每个进程打开三个文件描述符, 它们在unistd.h头文件中被定义为三个宏
  - `#define STDIN FILENO  0 // 标准输入`
  - `#define STDOUT FILENO 1 // 标准输出`
  - `#define STDERR FILENO 2 // 标准错误`

**文件读写位置** <p>
- 文件读写位置本质上是一个整数, **其含义为: 相对于文件首的偏移量** <p>
- 文件读写位置决定了从哪读往哪写, 文件读写位置随着读写操作同步变化, 其内容在**文件表项**中, 是由系统维护的 <p>

**系统I/O 与 标准I/O** <p>
- 当系统调用函数被执行时, 需要在用户态和内核态之间来回切换, 因此频繁执行系统调用函数会严重影响性能
- 标准库作了必要的优化, 内部维护一个缓冲区, 只在满足待定条件时才将缓冲区与系统内核同步, 借此执行降低系统调用的频率, 减少进程在用户台和内核态之间来回切换的次数, 提高运行性能 












